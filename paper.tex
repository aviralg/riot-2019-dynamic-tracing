\documentclass[acmsmall,review]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\setcopyright{none}

\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\usepackage{paralist}
\usepackage{listings}
\usepackage{xspace}

\lstset{ %
  basicstyle=\small\ttfamily
}

\newcommand{\code}[1]{\lstinline|#1|\xspace}
\newcommand{\Ie}{\emph{i.e.}\xspace}
\newcommand{\RDT}{RDT\xspace}

\title{A Dynamic Tracing Framework for R}

\author{Aviral Goel}
\affiliation{
  \institution{Northeastern University}
  \country{USA}
}
\email{goel.aviral@gmail.com}

\author{Filip KÅ™ikava}
\affiliation{
  \institution{Czech Technical University}
  \country{Czechia}
}
\email{filip.krikava@fit.cvut.cz}

\author{Jan Vitek}
\affiliation{
  \institution{Northeastern University}
  \country{USA}
}
\affiliation{
  \institution{Czech Technical University}
  \country{Czechia}
}
\email{j.vitek@neu.edu}

\authorsaddresses{}

\begin{document}

\maketitle

Static analysis of R code is hard. A combination of dynamic typing, laziness
with side-effects, introspection, metaprogramming using \code{substitute},
first-class environments and \code{eval} enable programming idioms that make it
nearly impossible to statically derive reliable insights. On the other hand,
most of the R packages available in CRAN and Bioconductor contain runnable
programs in the form of examples, tests and vignettes\footnote{The XXK CRAN
  packages contains YYK lines of runnable R code}. This makes R well-suited for
approaches based on dynamic analysis.
%
However, currently there is no dynamic tracing facilities other than the
coarse-grained \code{trace} function allowing one to only trace entry and exit
points of R closures.

In this talk we present \RDT, a scalable and modular dynamic tracing framework
that exposes many aspects of R, facilitating a fine-grained inspection of
programs. It has two components:
%
\begin{compactitem}[$-$]
\item a extension to GNU R Virtual Machine with probes that are triggered on
  specific program execution events. Dynamic analyses are written as external R
  packages that register callbacks to these probes. \RDT includes a number of
  probes such as function entry and exit, variable mutation and definition,
  garbage collection entry and exit, non-local jumps, promise creation and
  execution, eval entry and exit, S3 and S4 dispatch. These probes, along with
  a facility to store arbitrary state per tracing session are exposed as a
  small API\footnote{The complete extension to the virtual machine is about 1.8K lines
    of C code.}
  %The ability to store tracing session state avoids the need to use
  %global variables and thus encourages a functional design of dynamic analysis
  %that is easier to reason about.
\item a companion R package that provides an eclectic mix of functions for
  building scalable dynamic analyses using map-reduce programming model. This
  enables quick construction of multistage pipelines for analysis of tracing
  data. It contains functions to automate logging and memoization of partially
  analyzed data from each stage. Finally, it defines a data format for fast
  storage and retrieval of collected data with support for compressed data
  streaming.
\end{compactitem}

\bigskip
\indent An actual dynamic analysis is separated from the framework in a
standalone R package. This separation simplifies development and fosters reuse.
The package contains code that defines tracer state and registers callbacks for
the relevant events. When a callback is triggered, it receives the tracer state
together with the information about the event, \Ie, affected R objects along
with the relevant R interpreter state. A part of the API are utilities to
access fields of these objects as well as the global R interpreter state. This
includes the evaluation order of builtins and environment lookups through side
channels without triggering callbacks. Furthermore, \RDT can detect recursion
in callbacks, a consequence of the tracing algorithm inadvertently executing R
code that potentially modifies the program state. This is a common stumbling
block in na\"ive tracing attempts and our design captures these cases, reporting
them as meaningful error message. There is also an escape hatch in the form of
disabling specific probes when the R code in question is known to be benign.

We have used RDT for a large-scale study of the design and use of laziness in
R. Thanks to RDT, we managed to scale the dynamic analysis to YYYY R packages,
tracking over XXXXbn promises and XXXXbn events. The result is a reliable,
data-oriented understanding of the role of laziness in real-world R code.
%
We believe that using such approach of understanding program behavior, language
usage patterns and performance enabled by RDT is beneficial. It can help
improve the design of existing features, drive the design of new language
features and provide inspiration for the design of better libraries.
\end{document}
